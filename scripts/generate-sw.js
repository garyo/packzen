#!/usr/bin/env node
/**
 * Generate service worker with embedded version from version.ts
 * Run during build to ensure service worker cache matches build version
 */

import { readFileSync, writeFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Read the generated version info
const versionPath = join(__dirname, '../src/lib/version.ts');
const versionContent = readFileSync(versionPath, 'utf8');

// Extract version and commitHash using regex
const versionMatch = versionContent.match(/version: '([^']+)'/);
const commitHashMatch = versionContent.match(/commitHash: '([^']+)'/);

const version = versionMatch ? versionMatch[1] : 'unknown';
const commitHash = commitHashMatch ? commitHashMatch[1] : 'unknown';

// Use commitHash as the cache version (it's unique per build)
const cacheVersion = commitHash;

// Service worker template
const serviceWorkerContent = `/**
 * Service Worker for PackZen PWA
 * Auto-generated by scripts/generate-sw.js
 * Version: ${version} (${commitHash})
 */

const CACHE_VERSION = '${cacheVersion}';
const CACHE_NAME = \`packzen-\${CACHE_VERSION}\`;

// Files to cache immediately on install
const PRECACHE_URLS = [
  '/',
  '/dashboard/',
  '/trips/',
  '/all-items/',
  '/sign-in/',
  '/sign-up/',
  '/manifest.json',
  '/favicon.png',
  '/logo.png',
];

// Install event - cache essential resources
self.addEventListener('install', (event) => {
  console.log('Installing service worker version:', CACHE_VERSION);
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll(PRECACHE_URLS).catch((err) => {
        console.error('Failed to cache some resources:', err);
      });
    })
  );
  // Activate immediately
  self.skipWaiting();
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('Activating service worker version:', CACHE_VERSION);
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((name) => name.startsWith('packzen-') && name !== CACHE_NAME)
          .map((name) => {
            console.log('Deleting old cache:', name);
            return caches.delete(name);
          })
      );
    })
  );
  // Take control immediately
  self.clients.claim();
});

// Fetch event - stale-while-revalidate strategy with timeout
self.addEventListener('fetch', (event) => {
  // Skip non-GET requests
  if (event.request.method !== 'GET') {
    return;
  }

  // Skip chrome extensions and other origins
  if (!event.request.url.startsWith(self.location.origin)) {
    return;
  }

  const url = new URL(event.request.url);

  // Use cache-first for static assets (CSS, JS, images, fonts)
  const isStaticAsset = /\\.(css|js|png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot)$/i.test(url.pathname);

  if (isStaticAsset) {
    // Cache-first strategy for static assets
    event.respondWith(
      caches.match(event.request).then((cachedResponse) => {
        if (cachedResponse) {
          // Return cached version immediately, update in background
          fetchAndCache(event.request);
          return cachedResponse;
        }
        // Not in cache, fetch from network
        return fetchAndCache(event.request);
      })
    );
  } else {
    // Network-first with fast timeout for HTML/API requests
    event.respondWith(
      Promise.race([
        fetch(event.request).then((response) => {
          // Clone and cache successful responses (but not API responses)
          if (response.status === 200 && !url.pathname.startsWith('/api/')) {
            const responseToCache = response.clone();
            caches.open(CACHE_NAME).then((cache) => {
              cache.put(event.request, responseToCache);
            });
          }
          return response;
        }),
        // Fast timeout of 2 seconds for HTML/navigation
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error('Network timeout')), 2000)
        )
      ]).catch(() => {
        // Network failed or timed out, try cache first
        return caches.match(event.request).then((cachedResponse) => {
          if (cachedResponse) {
            return cachedResponse;
          }

          // For navigation requests, try to match with trailing slash or without
          if (event.request.mode === 'navigate') {
            const urlPath = url.pathname;
            const alternateUrl = urlPath.endsWith('/') ? urlPath.slice(0, -1) : urlPath + '/';

            return caches.match(alternateUrl).then(altResponse => {
              if (altResponse) return altResponse;

              // Final fallback to homepage
              return caches.match('/').then(response => {
                return response || new Response(
                  '<!DOCTYPE html><html><head><title>Offline</title></head><body><h1>App is offline</h1><p>Please check your connection and try again.</p></body></html>',
                  { headers: { 'Content-Type': 'text/html' } }
                );
              });
            });
          }

          // Return a basic offline response for other requests
          return new Response('Offline', {
            status: 503,
            statusText: 'Service Unavailable',
            headers: new Headers({
              'Content-Type': 'text/plain',
            }),
          });
        });
      })
    );
  }
});

// Helper function to fetch and cache
async function fetchAndCache(request) {
  try {
    const response = await fetch(request);
    if (response.status === 200) {
      const cache = await caches.open(CACHE_NAME);
      cache.put(request, response.clone());
    }
    return response;
  } catch (error) {
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    throw error;
  }
}
`;

// Write the generated service worker
const outputPath = join(__dirname, '../public/sw.js');
writeFileSync(outputPath, serviceWorkerContent, 'utf8');

console.log(`âœ“ Generated service worker with cache version: ${cacheVersion}`);
